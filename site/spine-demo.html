<html>
	<head>
        <meta charset=utf-8>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<style>
			body { margin: 0; }
			canvas { width: 640px; height: 480px; }
        </style>
        
        <script
        src="https://code.jquery.com/jquery-3.4.1.js"
        integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU="
        crossorigin="anonymous"></script>

        <script src="js/three.js"></script>
        <script src="js/spine.js"></script>
        <script src="js/OrbitControls.js"></script>
    </head>
    <body>
        <p>Testing spine rigging.</p>

        <div id="controls">
            <p>
                <select id="animation" onchange="selectAnimation()"></select>
            </p>
            <p id="skins"></p>
        </div>

        <div id="skin_div" style="float:right">

        </div>

		<script>

var allSkins = {};

$.getJSON('/skins', (w) => {
    let s = document.getElementById('skin_div');
    let t = document.createElement('table');
    let heading = document.createElement('tr');
    heading.innerHTML = '<th>Slot</th><th>Show</th><th>Rand</th><th>Skin</th><th>Color</th>';
    t.appendChild(heading);

    for (let slot in w) {
        allSkins[slot] = true;
        let tr = document.createElement('tr');

        let label = document.createElement('td');
        label.innerText = slot;
        tr.appendChild(label);

        let show = check('show-' + slot, default_checked[slot]);
        show.onchange = updateSkin;
        tr.appendChild(td(show));

        let rand = check('randomize-' + slot);
        tr.appendChild(td(rand));

        let s = document.createElement('select');
        s.id = 'slot-' + slot;
        s.style.width = '200px';
        s.onchange = updateSkin;
        for (let i in w[slot]) {
            if (
                w[slot][i] == slot + '.png' &&
                w[slot][i] != 'body.png'
            ) continue;
            if (w[slot][i] == 'debug.png') continue;
            let oo = document.createElement('option');
            oo.innerText = w[slot][i];
            oo.value = w[slot][i];
            s.appendChild(oo);
        }
        tr.appendChild(td(s));

        let span = document.createElement('td');
        let colCheck = check('color-' + slot);
        colCheck.onchange = updateSkin;
        span.appendChild(colCheck);
        let color = document.createElement('input');
        color.id = 'color-select-' + slot; 
        color.type = 'color';
        color.value = '#ffffff';
        color.onchange = updateSkin;
        span.appendChild(color);
        tr.appendChild(span);
        

        t.appendChild(tr);
    }

    s.appendChild(t);
});

var default_checked = {
    body: true,
    face: true,
}

function td(e) {
    let td = document.createElement('td');
    td.appendChild(e);
    return td;
}

function check(id, checked) {
    let d = document.createElement('input');
    d.setAttribute("type", "checkbox");
    d.id = id;      

    if (checked) d.checked = true;

    return d;
}

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( 640, 480 );
document.body.appendChild( renderer.domElement );

var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( { wireframe: true, color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );

camera.position.z = 10;

var controls = new THREE.OrbitControls(camera, renderer.domElement);

var loaded = false;
var spineBase = "/spine/";
var assetManager = new spine.threejs.AssetManager(spineBase);
var meshFile = 'rig.json';
var atlasFile = 'rig.atlas';
assetManager.loadText(meshFile);
assetManager.loadText(atlasFile);

var skeletonMesh;
var skeletonData;

function selectAnimation() {
    if (!skeletonMesh) return;

    let anim = document.getElementById('animation').value;

    skeletonMesh.state.setAnimation(0, anim, true);
}

let TIL = new THREE.ImageLoader();
var spineTextureCache = {};

function createAtlas(mods, callback) {
    let text = assetManager.get(atlasFile);
    mods = mods || {};

    let pending = 0;
    let atlas = new spine.TextureAtlas(text, (path) => {
        let actual = mods[path] || path;

        if (spineTextureCache[actual]) return spineTextureCache[actual];

        pending++;
        TIL.load(spineBase + actual, (image) => {
            pending--;
            spineTextureCache[actual] = new spine.threejs.ThreeJsTexture(image);
            if (pending == 0) {
                // recreate once all textures are ready.
                createAtlas(mods, callback);
            }
        });

        var fake = document.createElement("img");
        fake.width = 16;
        fake.height = 16;
        return new spine.FakeTexture(fake);
    });

    if (pending == 0) callback(new spine.AtlasAttachmentLoader(atlas));
}

function tintSkin(skin, r,g,b) {
    for (let i in skin.attachments) {
        for (let j in skin.attachments[i]) {
            skin.attachments[i][j].color.r = r;
            skin.attachments[i][j].color.g = g;
            skin.attachments[i][j].color.b = b;
        }
    }
}

function createPlayer(atlas) {
    let scale = 0.1;

    let skeletonJson = new spine.SkeletonJson(atlas);
    skeletonJson.scale = 0.1;

    let data = assetManager.get(meshFile);
    skeletonData = skeletonJson.readSkeletonData(data);

    let anims = document.getElementById('animation');
    if (anims.childElementCount == 0) {
        anims.innerHTML = ""; 
        for (let i in skeletonData.animations) {
            let d = document.createElement('option');
            d.value = skeletonData.animations[i].name;
            d.innerText = skeletonData.animations[i].name;
            anims.appendChild(d);
        }
    }

    if (skeletonMesh) cube.remove(skeletonMesh);

    skeletonMesh = new spine.threejs.SkeletonMesh(skeletonData);
    skeletonMesh.state.setAnimation(0, document.getElementById('animation').value, true);
    skeletonMesh.zOffset = 0.01;

    let skin = new spine.Skin('test');

    for (let i in allSkins) {
        let show = document.getElementById('show-' + i).checked;
        if (show) {
            skin.addSkin(skeletonData.findSkin(i));
        }
    }

    skeletonMesh.skeleton.setSkin(skin);
    skeletonMesh.skeleton.setSlotsToSetupPose();

    skeletonMesh.translateY(-5);
    skeletonMesh.scale.set(scale,scale,scale);
    cube.add(skeletonMesh);
}

function updateSkin() {
    let mods = {};

    // compute mods
    for (let i in allSkins) {
        let texture = document.getElementById('slot-' + i).value;
        if (texture != i + '.png') {
            mods['default/' + i + '/' + i + '.png'] = 'default/' + i + '/' + texture
        }
    }

    createAtlas(mods, (atlas) => {
        createPlayer(atlas);
    });
}

function load() {
    loaded = true;
    updateSkin();
}

function animate() {
    requestAnimationFrame( animate );

    if (!loaded && assetManager.isLoadingComplete()) {
        load();
    }

    if (skeletonMesh) {
        skeletonMesh.update(0.008);
        skeletonMesh.lookAt(camera.position.x, skeletonMesh.position.y, camera.position.z);
    }
	renderer.render( scene, camera );
}
animate();

		</script>
    </body>
</html>